/**
 * @providesModule YouTube
 */

import React from 'react';
import PropTypes from 'prop-types';
import ReactNative, {
  View,
  ViewPropTypes,
  Text,
  StyleSheet,
  requireNativeComponent,
  UIManager,
  NativeModules,
  BackAndroid,
  BackHandler as BackHandlerModule,
} from 'react-native';

const BackHandler = BackHandlerModule || BackAndroid;

const RCTYouTube = requireNativeComponent('ReactYouTube', YouTube, {
  nativeOnly: {
    onYouTubeError: true,
    onYouTubeErrorReady: true,
    onYouTubeErrorChangeState: true,
    onYouTubeErrorChangeQuality: true,
    onYouTubeChangeFullscreen: true,
  },
});

export default class YouTube extends React.Component {
  static propTypes = {
    apiKey: PropTypes.string.isRequired,
    videoId: PropTypes.string,
    videoIds: PropTypes.arrayOf(PropTypes.string),
    playlistId: PropTypes.string,
    play: PropTypes.bool,
    loop: PropTypes.bool,
    fullscreen: PropTypes.bool,
    controls: PropTypes.oneOf([0, 1, 2]),
    showFullscreenButton: PropTypes.bool,
    resumePlayAndroid: PropTypes.bool,
    onError: PropTypes.func,
    onReady: PropTypes.func,
    onChangeState: PropTypes.func,
    onChangeQuality: PropTypes.func,
    onChangeFullscreen: PropTypes.func,
    style: (ViewPropTypes && ViewPropTypes.style) || View.propTypes.style,
  };

  static defaultProps = {
    showFullscreenButton: true,
    resumePlayAndroid: true,
  };

  _interval = null;
  _timeout = null;
  constructor(props) {
    super(props);

    this.state = {
      moduleMargin: StyleSheet.hairlineWidth * 2,
      fullscreen: props.fullscreen,
    };
  }

  componentWillMount() {
    BackHandler.addEventListener('hardwareBackPress', this._backPress);

    // Periodically triggeting a forced unnoticable layout rendering until onReady to make sure the
    // native loading progress is shown
    this._interval = setInterval(() => {
      try {
        this.setState({ moduleMargin: Math.random() / 2 });
      } catch (e) { console.warn(e.message) }
    }, 250);
  }

  componentWillReceiveProps(nextProps) {
    // Translate next `fullscreen` prop to state
    if (nextProps.fullscreen !== this.props.fullscreen) {
      this.setState({ fullscreen: nextProps.fullscreen });
    }
  }

  componentWillUnmount() {
    BackHandler.removeEventListener('hardwareBackPress', this._backPress);
    this._nativeComponentRef = false
    clearInterval(this._interval);
    clearTimeout(this._timeout);
  }

  _backPress = () => {
    if (this.state.fullscreen) {
      this.setState({ fullscreen: false });
      return true;
    }
    return false;
  };

  _onError = event => {
    if (this.props.onError) this.props.onError(event.nativeEvent);
  };


  // refreshControls(controls) {
  //   // console.warn(UIManager.ReactYouTube.Commands.refreshControls+':'+parseInt(this.props.controls) + 'c'+this._nativeComponentRef)
  //   // let controls = this.props.controls || 2
  //   UIManager.dispatchViewManagerCommand(
  //     ReactNative.findNodeHandle(this._nativeComponentRef),
  //     UIManager.ReactYouTube.Commands.refreshControls,
  //     [controls],
  //   );
  // }

  _onReady = event => {
    clearInterval(this._interval);
    clearTimeout(this._timeout);

    // The Android YouTube native module is pretty problematic when it comes to mounting correctly
    // and rendering inside React-Native's views hierarchy. For now we must trigger some layout
    // changes to force a real render on it so it will smoothly appear after ready and show
    // controls. We also use the minimal margin to avoid `UNAUTHORIZED_OVERLAY` error from the
    // native module that is very sensitive to being covered or even touching its containing view.


    // another option is to refresh the controls, but this has worse effect on UX

    // this._timeout = setTimeout(() => {
    //   this.refreshControls(2);
    //   this._timeout = setTimeout(() => {
    //     this.refreshControls(1);
    //     this._timeout = setTimeout(() => {
    //       this.refreshControls(2);
    //       this._timeout = setTimeout(() => {
    //         this.refreshControls(1);
    //         this._timeout = setTimeout(() => {
    //           this.refreshControls(2);
    //           this._timeout = setTimeout(() => {
    //             this.refreshControls(1);
    //             this._timeout = setTimeout(() => {
    //               this.refreshControls(2);
    //               this._timeout = setTimeout(() => {
    //                 this.refreshControls(1);
    //                 this._timeout = setTimeout(() => {
    //                   this.refreshControls(2);
    //                   this._timeout = setTimeout(() => {
    //                     this.refreshControls(1);
    //                   }, 250);
    //                 }, 5000);
    //               }, 250);
    //             }, 5000);
    //           }, 250);
    //         }, 5000);
    //       }, 250);
    //     }, 5000);
    //   }, 250);

    // }, 250);

    // so we stick to resizing, but only the right margin which is not noticable

    try {
      this._timeout = setTimeout(() => {
        try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 2 }); } catch (e) { }
        this._timeout = setTimeout(() => {
          try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 1 }); } catch (e) { }
          this._timeout = setTimeout(() => {
            try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 2 }); } catch (e) { }
            this._timeout = setTimeout(() => {
              try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 1 }); } catch (e) { }
              this._timeout = setTimeout(() => {
                try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 2 }); } catch (e) { }
                this._timeout = setTimeout(() => {
                  try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 1 }); } catch (e) { }
                  this._timeout = setTimeout(() => {
                    try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 2 }); } catch (e) { }
                    this._timeout = setTimeout(() => {
                      try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 1 }); } catch (e) { }
                      this._timeout = setTimeout(() => {
                        try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 2 }); } catch (e) { }
                        this._timeout = setTimeout(() => {
                          try { this.setState({ moduleMargin: StyleSheet.hairlineWidth * 1 }); } catch (e) { }
                        }, 5000);
                      }, 5000);
                    }, 4000);
                  }, 4000);
                }, 3000);
              }, 3000);
            }, 2000);
          }, 2000);
        }, 1000);
      }, 250);
    } catch (e) { }

    if (this.props.onReady) this.props.onReady(event.nativeEvent);
  };

  _onChangeState = event => {
    if (this.props.onChangeState) this.props.onChangeState(event.nativeEvent);
  };

  _onChangeQuality = event => {
    if (this.props.onChangeQuality) this.props.onChangeQuality(event.nativeEvent);
  };

  _onChangeFullscreen = event => {
    const { isFullscreen } = event.nativeEvent;
    if (this.state.fullscreen !== isFullscreen) this.setState({ fullscreen: isFullscreen });
    if (this.props.onChangeFullscreen) this.props.onChangeFullscreen(event.nativeEvent);
  };

  seekTo(seconds) {
    if (!this._nativeComponentRef) return
    try {
      UIManager.dispatchViewManagerCommand(
        ReactNative.findNodeHandle(this._nativeComponentRef),
        UIManager.ReactYouTube.Commands.seekTo,
        [parseInt(seconds, 10)],
      );
    } catch (e) { console.warn(e.message) }
  }

  nextVideo() {
    if (!this._nativeComponentRef) return
    try {
      UIManager.dispatchViewManagerCommand(
        ReactNative.findNodeHandle(this._nativeComponentRef),
        UIManager.ReactYouTube.Commands.nextVideo,
        [],
      );
    } catch (e) { console.warn(e.message) }
  }

  previousVideo() {
    if (!this._nativeComponentRef) return
    try {
      UIManager.dispatchViewManagerCommand(
        ReactNative.findNodeHandle(this._nativeComponentRef),
        UIManager.ReactYouTube.Commands.previousVideo,
        [],
      );
    } catch (e) { console.warn(e.message) }
  }

  playVideoAt(index) {
    if (!this._nativeComponentRef) return
    try {
      UIManager.dispatchViewManagerCommand(
        ReactNative.findNodeHandle(this._nativeComponentRef),
        UIManager.ReactYouTube.Commands.playVideoAt,
        [parseInt(index, 10)],
      );
    } catch (e) { console.warn(e.message) }
  }

  videosIndex() {
    try {
      return new Promise((resolve, reject) =>
        NativeModules.YouTubeModule.videosIndex(ReactNative.findNodeHandle(this._nativeComponentRef))
          .then(index => resolve(index))
          .catch(errorMessage => reject(errorMessage)),
      );
    } catch (e) { console.warn(e.message) }
  }

  currentTime() {
    if (!this._nativeComponentRef) return
    try {
      return new Promise((resolve, reject) => {
        if (!this._nativeComponentRef) return
        return NativeModules.YouTubeModule.currentTime(ReactNative.findNodeHandle(this._nativeComponentRef))
          .then(currentTime => resolve(currentTime))
          .catch(errorMessage => reject(errorMessage))
      }
      );
    } catch (e) { console.warn(e.message) }

  }

  duration() {
    return new Promise((resolve, reject) => {
      if (!this._nativeComponentRef) return
      return NativeModules.YouTubeModule.duration(ReactNative.findNodeHandle(this._nativeComponentRef))
        .then(duration => resolve(duration))
        .catch(errorMessage => reject(errorMessage))
    }
    );
  }

  render() {
    try {
      let baseMargin = StyleSheet.hairlineWidth * 1
      return (
        <View style={[styles.container, this.props.style]}>
          <RCTYouTube
            ref={component => {
              if (!this._nativeComponentRef) this._nativeComponentRef = component;
            }}
            {...this.props}
            fullscreen={this.state.fullscreen}
            style={[styles.module, { margin: baseMargin, marginRight: baseMargin + this.state.moduleMargin }]}
            onYouTubeError={this._onError}
            onYouTubeReady={this._onReady}
            onYouTubeChangeState={this._onChangeState}
            onYouTubeChangeQuality={this._onChangeQuality}
            onYouTubeChangeFullscreen={this._onChangeFullscreen}
          />
        </View>
      );
    } catch (e) { console.warn(e.message) }
    return null
  }
}

const styles = StyleSheet.create({
  container: {
    // backgroundColor: 'black',
  },
  module: {
    flex: 1,
  },
});
